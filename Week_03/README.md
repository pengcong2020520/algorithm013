##### 学习总结
在递归中，由于go语言的特性，一般都是用切片实现对递归数组的操作。
而在go语言中,切片本身底层是一个指针，因此在操作时，如果没有操作好，经常容易让所有输出变成同样一个数组。所以在本周递归的学习中，总结一下几点：
首先定义一个递归函数：
func recuite(res *[][]int, n , m, levelint int, cur []int) {}
1.首先定义函数时，接受结果的res切片必然需要是一个指针，因为只有对指针进行操作才能使得在dfs函数中的操作可以体现在最终的输出结果中。
终止条件：*res = append(*res, append([]int{}, cur[:]...))
2.在终止条件中，如果传入cur，由于cur是指针，所以在每层递归的输出都是最终形态的数组值。所以上述表达相当于拷贝一份切片添加到res中去学习笔记
